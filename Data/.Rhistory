library(kableExtra)
library(purrr)
library(tibble)
# Step 1: Extract coefficients and SEs from each model
tidy_df <- imap_dfr(model_list, function(model, model_name) {
tidy(model) %>%
mutate(Model = model_name)
})
# Step 2: Format estimate and SE into single string
# Step 2.1: Define control variable terms to exclude
remove_vars <- c(
"green_percent_2017", "crime_rate_2017", "crime_rate_2018",
"imd_score", "crime_score", "env_score",
"pop_density_2017", "percent_nonwhite", "(Intercept)", "treated", "post",
"imd_decile::2:treated * post", "imd_decile::3:treated * post", "imd_decile::4:treated * post",
"imd_decile::5:treated * post", "rel_year::-4:treated", "rel_year::-3:treated",
"rel_year::-2:treated", "rel_year::0:treated"
)
# Step 2.2: Modify tidy_formatted creation to exclude controls
tidy_formatted <- tidy_df %>%
filter(!term %in% remove_vars) %>%  # <- Exclude control variables
mutate(
term_label = term,
formatted = sprintf("%.3f%s<br>(%.3f)",
estimate,
ifelse(p.value < 0.001, "***",
ifelse(p.value < 0.01, "**",
ifelse(p.value < 0.05, "*", ""))),
std.error)
) %>%
select(Model, term_label, formatted)
# Step 3: Reshape into wide format
table_data <- tidy_formatted %>%
pivot_wider(names_from = Model, values_from = formatted)
# Step 4: Clean up term labels
clean_names <- c(
"treated:post" = "Treated × Post",
"green_change:post" = "Green Change × Post",
"post:near_treated" = "Near Treated Area × Post",
"dist_band::within_500m:post" = "Within 500m of Treated × Post",
"dist_band::500m_1km:post" = "500m–1km from Treated × Post",
"dist_band::1km_2km:post" = "1km–2km from Treated × Post",
"imd_decile::6:treated * post" = "Treated × Post × IMD Decile 6",
"imd_decile::7:treated * post" = "Treated × Post × IMD Decile 7",
"imd_decile::8:treated * post" = "Treated × Post × IMD Decile 8",
"imd_decile::9:treated * post" = "Treated × Post × IMD Decile 9",
"imd_decile::10:treated * post" = "Treated × Post × IMD Decile 10",
"rel_year::1:treated" = "Event Study Lead/Lag: Year 1",
"rel_year::2:treated" = "Event Study Lead/Lag: Year 2",
"rel_year::3:treated" = "Event Study Lead/Lag: Year 3"
)
table_data$term_label <- recode(table_data$term_label, !!!clean_names)
# Step 5: Replace NAs with blanks
table_data[is.na(table_data)] <- ""
# Step 6: Automatically determine controls per model
feature_summary <- imap_dfr(model_list, function(model, model_name) {
terms <- tryCatch({
if ("fixest" %in% class(model)) {
all.vars(model$fml_all$linear)
} else {
attr(model$terms, "term.labels")
}
}, error = function(e) character(0))
terms <- names(coef(model))
fixef_vars <- model$fixef_vars %||% character(0)  # safely handles NULL
tibble(
Model = model_name,
Observations = format(nobs(model), big.mark = ","),
`LSOA Fixed Effects` = if ("LSOA.code" %in% fixef_vars) "Yes" else "No",
`Year Fixed Effects` = if ("Year" %in% fixef_vars) "Yes" else "No",
`Socioeconomic Controls` = if (any(grepl("imd|nonwhite|pop_density", terms))) "Yes" else "No",
`Environmental Controls` = if (any(grepl("green_percent|crime_score|env_score", terms))) "Yes" else "No"
)
}) %>%
pivot_longer(-Model, names_to = "Term", values_to = "value") %>%
pivot_wider(names_from = Model, values_from = value)
# Step 7: Combine coefficients and summary rows
table_full <- bind_rows(
table_data %>% rename(Term = term_label),
feature_summary %>% mutate(row_type = ifelse(Term == "Observations", "Observations", "Control"))
)
# Step 8: Define row type for styling
table_full <- table_full %>%
mutate(
row_type = case_when(
Term == "Observations" ~ "Observations",
Term %in% c("LSOA Fixed Effects", "Year Fixed Effects",
"Socioeconomic Controls", "Environmental Controls") ~ "Control",
TRUE ~ "Main"
)
)
# Step 9: Build the styled HTML table
table_html <- kable(table_full %>% select(-row_type), format = "html", escape = FALSE,
col.names = c("", names(model_list))) %>%
kable_styling(
bootstrap_options = c("striped", "condensed", "responsive"),
full_width = FALSE,
font_size = 14,
position = "center"
) %>%
add_header_above(c("[Main Models — From Baseline DiD to Spatial and Heterogeneous Effects]" = ncol(table_full) - 1), bold = FALSE) %>%
row_spec(0, bold = FALSE, extra_css = "font-weight: normal;") %>%
row_spec(
which(table_full$row_type == "Control")[1],
bold = FALSE,
extra_css = "border-top: 1px solid;"
) %>%
footnote(
general = "Standard errors in parentheses. All regressions are clustered at LSOA level. *** p < 0.001; ** p < 0.01; * p < 0.05.",
general_title = "Note:"
)
# Step 10: Show and/or save the table
table_html
# Optionally save
save_kable(table_html, file = "main_models.html")
model_list <- list(
#"1. Basic DiD" = model1,
"1. DiD with Controls" = model2,
"2. Fixed Effects DiD" = model3,
"3. Continuous Fixed Effects DiD" = model4,
#"5. Spillover (Binary)" = model5,
"4. Spillover (Distance Bands)" = model6,
"5. Heterogeneous (IMD)" = model7,
"6. Event Study" = model8
)
# Required libraries
library(broom)
library(dplyr)
library(tidyr)
library(kableExtra)
library(purrr)
library(tibble)
# Step 1: Extract coefficients and SEs from each model
tidy_df <- imap_dfr(model_list, function(model, model_name) {
tidy(model) %>%
mutate(Model = model_name)
})
# Step 2: Format estimate and SE into single string
# Step 2.1: Define control variable terms to exclude
remove_vars <- c(
"green_percent_2017", "crime_rate_2017", "crime_rate_2018",
"imd_score", "crime_score", "env_score",
"pop_density_2017", "percent_nonwhite", "(Intercept)", "treated", "post",
"imd_decile::2:treated * post", "imd_decile::3:treated * post", "imd_decile::4:treated * post",
"imd_decile::5:treated * post", "rel_year::-4:treated", "rel_year::-3:treated",
"rel_year::-2:treated", "rel_year::0:treated"
)
# Step 2.2: Modify tidy_formatted creation to exclude controls
tidy_formatted <- tidy_df %>%
filter(!term %in% remove_vars) %>%  # <- Exclude control variables
mutate(
term_label = term,
formatted = sprintf("%.3f%s<br>(%.3f)",
estimate,
ifelse(p.value < 0.001, "***",
ifelse(p.value < 0.01, "**",
ifelse(p.value < 0.05, "*", ""))),
std.error)
) %>%
select(Model, term_label, formatted)
# Step 3: Reshape into wide format
table_data <- tidy_formatted %>%
pivot_wider(names_from = Model, values_from = formatted)
# Step 4: Clean up term labels
clean_names <- c(
"treated:post" = "Treated × Post",
"green_change:post" = "Green Change × Post",
"post:near_treated" = "Near Treated Area × Post",
"dist_band::within_500m:post" = "Within 500m of Treated × Post",
"dist_band::500m_1km:post" = "500m–1km from Treated × Post",
"dist_band::1km_2km:post" = "1km–2km from Treated × Post",
"imd_decile::6:treated * post" = "Treated × Post × IMD Decile 6",
"imd_decile::7:treated * post" = "Treated × Post × IMD Decile 7",
"imd_decile::8:treated * post" = "Treated × Post × IMD Decile 8",
"imd_decile::9:treated * post" = "Treated × Post × IMD Decile 9",
"imd_decile::10:treated * post" = "Treated × Post × IMD Decile 10",
"rel_year::1:treated" = "Event Study Lead/Lag: Year 1",
"rel_year::2:treated" = "Event Study Lead/Lag: Year 2",
"rel_year::3:treated" = "Event Study Lead/Lag: Year 3"
)
table_data$term_label <- recode(table_data$term_label, !!!clean_names)
# Step 5: Replace NAs with blanks
table_data[is.na(table_data)] <- ""
# Step 6: Automatically determine controls per model
feature_summary <- imap_dfr(model_list, function(model, model_name) {
terms <- tryCatch({
if ("fixest" %in% class(model)) {
all.vars(model$fml_all$linear)
} else {
attr(model$terms, "term.labels")
}
}, error = function(e) character(0))
terms <- names(coef(model))
fixef_vars <- model$fixef_vars %||% character(0)  # safely handles NULL
tibble(
Model = model_name,
Observations = format(nobs(model), big.mark = ","),
`LSOA Fixed Effects` = if ("LSOA.code" %in% fixef_vars) "Yes" else "No",
`Year Fixed Effects` = if ("Year" %in% fixef_vars) "Yes" else "No",
`Socioeconomic Controls` = if (any(grepl("imd|nonwhite|pop_density", terms))) "Yes" else "No",
`Environmental Controls` = if (any(grepl("green_percent|crime_score|env_score", terms))) "Yes" else "No"
)
}) %>%
pivot_longer(-Model, names_to = "Term", values_to = "value") %>%
pivot_wider(names_from = Model, values_from = value)
# Step 7: Combine coefficients and summary rows
table_full <- bind_rows(
table_data %>% rename(Term = term_label),
feature_summary %>% mutate(row_type = ifelse(Term == "Observations", "Observations", "Control"))
)
# Step 8: Define row type for styling
table_full <- table_full %>%
mutate(
row_type = case_when(
Term == "Observations" ~ "Observations",
Term %in% c("LSOA Fixed Effects", "Year Fixed Effects",
"Socioeconomic Controls", "Environmental Controls") ~ "Control",
TRUE ~ "Main"
)
)
# Step 9: Build the styled HTML table
table_html <- kable(table_full %>% select(-row_type), format = "html", escape = FALSE,
col.names = c("", names(model_list))) %>%
kable_styling(
bootstrap_options = c("striped", "condensed", "responsive"),
full_width = FALSE,
font_size = 14,
position = "center"
) %>%
add_header_above(c("[Main Models — From Baseline DiD to Spatial and Heterogeneous Effects]" = ncol(table_full) - 1), bold = FALSE) %>%
row_spec(0, bold = FALSE, extra_css = "font-weight: normal;") %>%
row_spec(
which(table_full$row_type == "Control")[1],
bold = FALSE,
extra_css = "border-top: 1px solid;"
) %>%
footnote(
general = "Standard errors in parentheses. All regressions are clustered at LSOA level. *** p < 0.001; ** p < 0.01; * p < 0.05.",
general_title = "Note:"
)
# Step 10: Show and/or save the table
table_html
# Optionally save
save_kable(table_html, file = "main_models.html")
library(spatialreg)
library(spdep)
library(sf)
# 1. Join attributes to spatial geometry
spatial_data <- lsoa_sf %>%
select(lsoa21cd, geometry) %>%
left_join(matched_panel, by = c("lsoa21cd" = "LSOA.code"))
# 2. Drop rows with missing values in relevant covariates
sdm_data <- spatial_data %>%
select(
crime_rate, treated, green_percent_2017, imd_score, pop_density_2017, geometry
) %>%
drop_na()
# 3. Convert to sp object (required by spatialreg)
sdm_sp <- as_Spatial(sdm_data)
# 4. Define spatial weights using Queen contiguity
nb <- poly2nb(sdm_sp, queen = TRUE)
lw <- nb2listw(nb, style = "W", zero.policy = TRUE)
# 5. Fit Spatial Durbin Model
sdm_model <- lagsarlm(
crime_rate ~ treated + green_percent_2017 + imd_score + pop_density_2017,
data = sdm_sp@data,
listw = lw,
type = "mixed",       # <- this enables SDM
zero.policy = TRUE
)
# 6. Summarize results
summary(sdm_model)
impacts_sdm <- impacts(sdm_model, listw = lw, R = 1000)
summary(impacts_sdm, zstats = TRUE)
# -----------------------------------------
# Combined Table of SAR And SDM Models
# -----------------------------------------
# 1. Create a list of your SAR and SDM models
spatial_model_list <- list(
#"1. SAR Model" = sar_model,
"7. SDM Model" = sdm_model
)
# Required libraries
library(broom)
library(dplyr)
library(tidyr)
library(kableExtra)
library(purrr)
library(tibble)
# 2. Tidy and format coefficient estimates
spatial_tidy_df <- imap_dfr(spatial_model_list, function(model, model_name) {
tidy(model) %>%
mutate(Model = model_name)
})
# 3. Format coefficient and SE into one cell
spatial_tidy_formatted <- spatial_tidy_df %>%
filter(!term %in% c("(Intercept)")) %>%
mutate(
term_label = term,
formatted = sprintf("%.3f%s<br>(%.3f)",
estimate,
ifelse(p.value < 0.001, "***",
ifelse(p.value < 0.01, "**",
ifelse(p.value < 0.05, "*", ""))),
std.error)
) %>%
select(Model, term_label, formatted)
# 4. Pivot to wide format
spatial_table_data <- spatial_tidy_formatted %>%
pivot_wider(names_from = Model, values_from = formatted)
# 5. Clean up labels (optional)
spatial_clean_names <- c(
"treated" = "Treated",
"green_percent_2017" = "Green Coverage (2017)",
"imd_score" = "IMD Score",
"pop_density_2017" = "Population Density (2017)",
"lag.treated" = "Lagged: Treated",
"lag.green_percent_2017" = "Lagged: Green Coverage",
"lag.imd_score" = "Lagged: IMD Score",
"lag.pop_density_2017" = "Lagged: Pop Density"
)
spatial_table_data$term_label <- recode(spatial_table_data$term_label, !!!spatial_clean_names)
# 6. Replace NAs with blanks
spatial_table_data[is.na(spatial_table_data)] <- ""
# 7. Add model-level information (observations, controls)
spatial_feature_summary <- imap_dfr(spatial_model_list, function(model, model_name) {
terms <- names(coef(model))
tibble(
Model = model_name,
Observations = format(nrow(model$X), big.mark = ","),
`Spatial Lag` = if (any(grepl("^lag\\.", terms))) "Yes" else "No",
`Socioeconomic Controls` = if (any(grepl("imd | pop_density", terms))) "Yes" else "No",
`Environmental Controls` = if (any(grepl("green_percent", terms))) "Yes" else "No"
)
}) %>%
pivot_longer(-Model, names_to = "Term", values_to = "value") %>%
pivot_wider(names_from = Model, values_from = value)
# 8. Combine with coefficients
spatial_table_full <- bind_rows(
spatial_table_data %>% rename(Term = term_label),
spatial_feature_summary %>% mutate(row_type = ifelse(Term == "Observations", "Observations", "Control"))
)
# 9. Classify rows for styling
spatial_table_full <- spatial_table_full %>%
mutate(
row_type = case_when(
Term == "Observations" ~ "Observations",
Term %in% c("Spatial Lag", "Socioeconomic Controls", "Environmental Controls") ~ "Control",
TRUE ~ "Main"
)
)
# 10. Generate HTML table
spatial_table_html <- kable(spatial_table_full %>% select(-row_type), format = "html", escape = FALSE,
col.names = c("", names(spatial_model_list))) %>%
kable_styling(
bootstrap_options = c("striped", "condensed", "responsive"),
full_width = FALSE,
font_size = 14,
position = "center"
) %>%
add_header_above(c("[Spatial Econometric Models - SAR and SDM]" = ncol(spatial_table_full) - 1), bold = FALSE) %>%
row_spec(0, bold = FALSE, extra_css = "font-weight: normal;") %>%
row_spec(
which(spatial_table_full$row_type == "Control")[1],
bold = FALSE,
extra_css = "border-top: 1px solid;"
) %>%
footnote(
general = "Standard errors in parentheses. All models use spatially weighted contiguity. *** p < 0.001; ** p < 0.01; * p < 0.05.",
general_title = "Note:"
)
# 11. View or save the table
spatial_table_html
save_kable(spatial_table_html, file = "spatial_models.html")
# 7. Add model-level information (observations, controls)
spatial_feature_summary <- imap_dfr(spatial_model_list, function(model, model_name) {
terms <- names(coef(model))
tibble(
Model = model_name,
Observations = format(nrow(model$X), big.mark = ","),
`Spatial Lag` = if (any(grepl("^lag\\.", terms))) "Yes" else "No",
`Socioeconomic Controls` = if (any(grepl("imd_ | pop_density", terms))) "Yes" else "No",
`Environmental Controls` = if (any(grepl("green_percent", terms))) "Yes" else "No"
)
}) %>%
pivot_longer(-Model, names_to = "Term", values_to = "value") %>%
pivot_wider(names_from = Model, values_from = value)
# 8. Combine with coefficients
spatial_table_full <- bind_rows(
spatial_table_data %>% rename(Term = term_label),
spatial_feature_summary %>% mutate(row_type = ifelse(Term == "Observations", "Observations", "Control"))
)
# 9. Classify rows for styling
spatial_table_full <- spatial_table_full %>%
mutate(
row_type = case_when(
Term == "Observations" ~ "Observations",
Term %in% c("Spatial Lag", "Socioeconomic Controls", "Environmental Controls") ~ "Control",
TRUE ~ "Main"
)
)
# 10. Generate HTML table
spatial_table_html <- kable(spatial_table_full %>% select(-row_type), format = "html", escape = FALSE,
col.names = c("", names(spatial_model_list))) %>%
kable_styling(
bootstrap_options = c("striped", "condensed", "responsive"),
full_width = FALSE,
font_size = 14,
position = "center"
) %>%
add_header_above(c("[Spatial Econometric Models - SAR and SDM]" = ncol(spatial_table_full) - 1), bold = FALSE) %>%
row_spec(0, bold = FALSE, extra_css = "font-weight: normal;") %>%
row_spec(
which(spatial_table_full$row_type == "Control")[1],
bold = FALSE,
extra_css = "border-top: 1px solid;"
) %>%
footnote(
general = "Standard errors in parentheses. All models use spatially weighted contiguity. *** p < 0.001; ** p < 0.01; * p < 0.05.",
general_title = "Note:"
)
# 11. View or save the table
spatial_table_html
save_kable(spatial_table_html, file = "spatial_models.html")
# 7. Add model-level information (observations, controls)
spatial_feature_summary <- imap_dfr(spatial_model_list, function(model, model_name) {
terms <- names(coef(model))
tibble(
Model = model_name,
Observations = format(nrow(model$X), big.mark = ","),
`Spatial Lag` = if (any(grepl("^lag\\.", terms))) "Yes" else "No",
`Socioeconomic Controls` = if (any(grepl("imd_|pop_density", terms))) "Yes" else "No",
`Environmental Controls` = if (any(grepl("green_percent", terms))) "Yes" else "No"
)
}) %>%
pivot_longer(-Model, names_to = "Term", values_to = "value") %>%
pivot_wider(names_from = Model, values_from = value)
# 8. Combine with coefficients
spatial_table_full <- bind_rows(
spatial_table_data %>% rename(Term = term_label),
spatial_feature_summary %>% mutate(row_type = ifelse(Term == "Observations", "Observations", "Control"))
)
# 9. Classify rows for styling
spatial_table_full <- spatial_table_full %>%
mutate(
row_type = case_when(
Term == "Observations" ~ "Observations",
Term %in% c("Spatial Lag", "Socioeconomic Controls", "Environmental Controls") ~ "Control",
TRUE ~ "Main"
)
)
# 10. Generate HTML table
spatial_table_html <- kable(spatial_table_full %>% select(-row_type), format = "html", escape = FALSE,
col.names = c("", names(spatial_model_list))) %>%
kable_styling(
bootstrap_options = c("striped", "condensed", "responsive"),
full_width = FALSE,
font_size = 14,
position = "center"
) %>%
add_header_above(c("[Spatial Econometric Models - SAR and SDM]" = ncol(spatial_table_full) - 1), bold = FALSE) %>%
row_spec(0, bold = FALSE, extra_css = "font-weight: normal;") %>%
row_spec(
which(spatial_table_full$row_type == "Control")[1],
bold = FALSE,
extra_css = "border-top: 1px solid;"
) %>%
footnote(
general = "Standard errors in parentheses. All models use spatially weighted contiguity. *** p < 0.001; ** p < 0.01; * p < 0.05.",
general_title = "Note:"
)
# 11. View or save the table
spatial_table_html
knitr::opts_chunk$set(echo = TRUE)
install.packages(c("sf", "ggplot2","cowplot", "tmap", "dplyr", "readr", "viridis", "spdep", "MatchIt", "spatialreg"))
library(sf)
install.packages(c("sf", "ggplot2", "cowplot", "tmap", "dplyr", "readr", "viridis", "spdep", "MatchIt", "spatialreg"))
library(ggplot2)
library(tmap)
library(dplyr)
library(purrr)
library(fs)
library(readxl)
library(tidyr)
setwd("~/Desktop/My Data")
# Set path to folder with borough-level LSOA shapefiles
lsoa_dir <- "~/Desktop/LB_shp/"  # change to your actual folder path
# List all .shp files
lsoa_shps <- dir_ls(lsoa_dir, regexp = "\\.shp$")
# Read and combine all into a single `sf` object
lsoa_sf <- map_dfr(lsoa_shps, ~ {
shp <- st_read(.x, quiet = TRUE)
st_transform(shp, 27700)  # ensure CRS is correct
})
View(lsoa_sf)
library(readr)
greenspace_comparison <- read_csv("~/Desktop/Greenspace_Comparison_2017_2024.csv") %>%
mutate(lsoa21cd = as.character(lsoa21cd))
greenspace_comparison <- greenspace_comparison %>%
mutate(area_km2 = total_area_sqm_2017 / 1e6)
# Load required library
library(dplyr)
# Set the path to your directory containing the CSV files
data_dir <- "~/Desktop/My Data/Crimes"
# List all street-level CSVs for Met and City of London
file_list <- list.files(path = data_dir,
pattern = "-(metropolitan|city-of-london)-street\\.csv$",
full.names = TRUE)
# Read and combine all files into one data frame
all_crime_data <- file_list %>%
lapply(read.csv, stringsAsFactors = FALSE) %>%
bind_rows()
